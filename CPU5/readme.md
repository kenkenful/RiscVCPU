## CPU5 
デコードステージと実行ステージの間にパイプラインレジスタを挿入しました。</br>
実行ステージの結果を直後の命令が使用する場合にハザードが発生します。

例えば、
```
後続のadd命令が、先行のadd命令の結果を参照する場合
add a5 a4 a5
add a5 a4 a5
```
```
後続のload命令が、先行のadd命令の結果を参照する場合
lw a1 24(sp)
add a5 a1 a5
```

クロックの立ち上がり（①）で、load命令がALUに入力、loadするアドレスが計算され、
半サイクル後のクロックの立ち下がり（②）でデータメモリからデータが読み出されます。
次のクロックの立ち上がり（③）でloadしたデータはレジスタファイルに書かれるが、レジスタファイルからの読み出しはクロックに同期していないため書かれたと同時にロードデータは読み出されます(③)。
読み出されたロードデータはパイプラインレジスタを経て、④のALUの入力となるため、2クロック後にALUに入ることになり、本来ならば、1クロック後にほしいロードしたデータが間に合っていないことになるのです。
そこで、紫線のようにロードしたデータをレジスタファイルに書き込まないで、直接レジスタファイルの出力線に入れてしまうことで2クロック遅延を1クロック遅延に解消してしまいます。（フォワーディング）
![CPU](https://github.com/user-attachments/assets/2efc56b3-32d6-401d-834a-ac5dcc4590c9)

以下のマシンコードでハザードをチェックしています。
```
 00300413  # s0 <- 3         レジスタs0に3を入れる
 00400713  # a4 <- 4         レジスタa4に4を入れる
 00500793  # a5 <- 5         レジスタa5に5を入れる
 00004137  # lui sp,0x4      0000 0000 0000 0000 0000 0100 0000 0000 0000 をレジスタspに入れる。
 fff10113  # addi sp,sp,-1   0000 0000 0000 0000 0000 0100 0000 0000 0000 + 1111 1111 1111 1111 1111 1111 1111 1111 (-1)
                             = 0000 0000 0000 0000 0000 0011 1111 1111 1111 (0x3fff)
                             なので、スタックのTopが0X3FFFになる。
 fe010113  # addi sp,sp,-32　スタックを確保
 00812c23　# sw s0 24(sp)    s0の値（３）をデータメモリにストア
 00f707b3  # add a5 a4 a5    答えは９
 00f707b3  # add a5 a4 a5 　　答えは13 (0xd) 
 01812583  # lw a1 24(sp)    データメモリからレジスタa1にロード
 00f587b3　# add a5 a1 a5     答えは16 (0x10)
```
