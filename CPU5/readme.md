## CPU5 
デコードステージと実行ステージの間にパイプラインレジスタを挿入しました。</br>
実行ステージの結果を直後の命令が使用する場合にハザードが発生します。

例えば、
```
後続のadd命令が、先行のadd命令の結果を参照する場合
add a5 a4 a5
add a5 a4 a5
```
```
後続のload命令が、先行のadd命令の結果を参照する場合
lw a1 24(sp)
add a5 a1 a5
```
ALUでの計算結果を黒線で表し、０クロック目とすると、</br>
赤線は１クロック後、緑線は２クロック後となります。</br>
すなわち、ロードした結果が、ALUの入力に入るのに2クロックかかるため、次のadd命令（１クロック後）に間に合わないことになります。</br>
ちなみに、レジスタファイルに関しては、読み出しをクロックに同期させていないため書いた瞬間読み出すことができ、レジスタファイルの入出力は共に赤線となります。

ロードした結果を１クロック後にALUに入れるため、紫線で記載したようにALUの計算結果を前のステージに入れて、1クロック後に取り出すようにします。（フォワーディング、バイパシング）
![CPU5](https://github.com/user-attachments/assets/e05487fe-1d3c-4a2e-a900-4ac3ea076bea)

以下のマシンコードでハザードをチェックしています。
```
 00300413  # s0 <- 3         レジスタs0に3を入れる
 00400713  # a4 <- 4         レジスタa4に4を入れる
 00500793  # a5 <- 5         レジスタa5に5を入れる
 00004137  # lui sp,0x4      0000 0000 0000 0000 0000 0100 0000 0000 0000 をレジスタspに入れる。
 fff10113  # addi sp,sp,-1   0000 0000 0000 0000 0000 0100 0000 0000 0000 + 1111 1111 1111 1111 1111 1111 1111 1111 (-1)
                             = 0000 0000 0000 0000 0000 0011 1111 1111 1111 (0x3fff)
                             なので、スタックのTopが0X3FFFになる。
 fe010113  # addi sp,sp,-32　スタックを確保
 00812c23　# sw s0 24(sp)    s0の値（３）をデータメモリにストア
 00f707b3  # add a5 a4 a5    答えは９
 00f707b3  # add a5 a4 a5 　　答えは13 (0xd) 
 01812583  # lw a1 24(sp)    データメモリからレジスタa1にロード
 00f587b3　# add a5 a1 a5     答えは16 (0x10)
```
