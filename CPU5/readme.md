## CPU5 
デコードステージと実行ステージの間にパイプラインレジスタを挿入すると、
実行ステージの結果を直後の命令が使用する場合にハザードが発生します。

例えば、
```
後続のadd命令が、先行のadd命令の結果を参照する場合
add a5 a4 a5
add a5 a4 a5
```
とか</br>
```
後続のload命令が、先行のadd命令の結果を参照する場合
lw a1 24(sp)
add a5 a1 a5
```
などです。</br></br>
クロックの立ち上がり（①）で、load命令がALUに入り、ALUにてloadアドレスが計算され、
半サイクル後のクロックの立ち下がり（②）でデータメモリからデータが読み出されます（赤線）。
次のクロックの立ち上がり（③）でロードデータはレジスタファイルに書かれますが、</br>レジスタファイルからの読み出しはクロックに同期していないため、書いたと同時に読み出し可能(③)で
読み出されたロードデータはパイプラインレジスタのため次のクロックの立ち上がり（④）でALUの入力となるため、結局ロードしたデータは、ロード命令が実行されてから2クロック後にALUに入ることになります。</br>本来ならば、1クロック後（③）にほしいデータが間に合わないため、紫線のようにロードしたデータをレジスタファイルに書き込まないで、直接レジスタファイルの出力線に入れてしまうことで2クロック遅延（④）を1クロック遅延（③）に解消します。（フォワーディング）
![CPU](https://github.com/user-attachments/assets/2efc56b3-32d6-401d-834a-ac5dcc4590c9)

以下のマシンコードでハザードをチェック。
```
 00300413  # s0 <- 3         レジスタs0に3を入れる
 00400713  # a4 <- 4         レジスタa4に4を入れる
 00500793  # a5 <- 5         レジスタa5に5を入れる
 00004137  # lui sp,0x4      0000 0000 0000 0000 0000 0100 0000 0000 0000 をレジスタspに入れる。
 fff10113  # addi sp,sp,-1   0000 0000 0000 0000 0000 0100 0000 0000 0000 + 1111 1111 1111 1111 1111 1111 1111 1111 (-1)
                             = 0000 0000 0000 0000 0000 0011 1111 1111 1111 (0x3fff)
                             なので、スタックのTopが0X3FFFになる。
 fe010113  # addi sp,sp,-32　スタックを確保
 00812c23　# sw s0 24(sp)    s0の値（３）をデータメモリにストア
 00f707b3  # add a5 a4 a5    答えは9=5+4
 00f707b3  # add a5 a4 a5 　　答えは13 (0xd) =4+9 
 01812583  # lw a1 24(sp)    データメモリからレジスタa1にロード
 00f587b3　# add a5 a1 a5     答えは16 (0x10) =3+13
```
